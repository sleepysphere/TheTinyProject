\chapter{Core Implementation (Section A)}
\label{chap:core_classes}

This chapter details the design and implementation of the core C++ classes for vector and matrix operations, as well as classes for solving linear systems, as required by Part A of the project specification.

\section{Vector Class}
\label{sec:vector_class}

The \texttt{Vector} class was developed to represent mathematical vectors and perform common vector operations. Its implementation in \texttt{Vector.h} and \texttt{Vector.cpp} addresses the specified requirements.

\begin{figure}
\lstinputlisting[language=C++, linerange={8-58}, caption={Implementation of the \texttt{Vector} class}, captionpos=b]{../include/Vector.h}
\end{figure}

\subsection{Key Features}
Key features of the \texttt{Vector} class include: 
\begin{itemize}
    \item \textbf{Manage Memory} Used dynamic memory allocation to store vector elements, ensuring efficient memory usage.
        \begin{itemize}
                \item Creating an empty vector with a default constructor \texttt{Vector()}.
                \item Initalizing a vector with a specified size using the constructor \texttt{Vector(int size)}.
                \item Perform deep copy with constructor \texttt{Vector}.
                \item Free the allocated memory in the destructor \texttt{~Vector()}.
            \end{itemize}
    The private members are \texttt{mSize} (the size of the array) and \texttt{mData} (a pointer to a \texttt{double} storing the vector elements).

    \item \textbf{Overload Operators}
    \begin{itemize}
        \item The assignment operator (\texttt{=}) is overloaded to ensure deep copying of vector contents, correctly handling cases of self-assignment and vectors of differing sizes.
        \item Unary operators (\texttt{+}) and (\texttt{-}) are overloaded: (\texttt{+}) returns a duplicate of the vector, while (\texttt{-}) produces a new vector with all elements negated.
        \item Binary operators (\texttt{+}) and (\texttt{-}) are overloaded for vector addition and subtraction, and (\texttt{*}) for multiplying by a scalar. Assertions (\texttt{assert}) are used to verify that vectors involved in addition or subtraction have matching sizes.
        \item The square bracket operator (\texttt{[]}) is overloaded to provide 0-based element access, with \texttt{assert} used to check index validity. Both \texttt{const} and non-\texttt{const} versions are implemented.
        \item The round bracket operator (\texttt{()}) is overloaded for 1-based element access, also using \texttt{assert} for bounds checking. Both \texttt{const} and non-\texttt{const} versions are available.
        \item The output stream operator (\texttt{operator<<}) is overloaded as a friend function to enable easy printing of vector contents.
        \end{itemize}
    \item \textbf{Norm Calculation:} The public method \texttt{double Norm(int p = 2) const} computes the p-norm of the vector, with the default being the Euclidean (L2) norm.
    \item \textbf{Accessor:} The method \texttt{int GetSize() const} provides the current size of the vector.

\end{itemize}

\section{Matrix Class}
\label{sec:matrix_class}

The \texttt{Matrix} class, defined in \texttt{Matrix.h} and \texttt{Matrix.cpp}, is used for handling and operating on two-dimensional matrices.

\begin{figure}
\lstinputlisting[language=C++, linerange={7-48}, caption={Implementation of the \texttt{Matrix} class}, captionpos=b]{../include/Matrix.h}
\end{figure}

\subsection{Features and Implementation}
\begin{itemize}
    \item \textbf{Private Members:} The class maintains the number of rows and columns as private integers (\texttt{mNumRows}, \texttt{mNumCols}), and stores matrix data in a dynamically allocated 2D array (\texttt{mData}, a \texttt{double**}). Memory management is handled by private methods \texttt{AllocateMemory()} and \texttt{DeallocateMemory()}.
    \item \textbf{Constructors and Destructor:}
        \begin{sloppypar}
        \begin{itemize}
            \item The default constructor \texttt{Matrix()} creates an empty matrix.
            \item The constructor \texttt{Matrix(int numRows, int numCols)} allocates memory for the specified dimensions and initializes all elements to zero.
            \item The copy constructor \texttt{Matrix(const Matrix\& otherMatrix)} performs a deep copy of another matrix.
            \item The destructor \texttt{\textasciitilde Matrix()} releases all allocated memory.
        \end{itemize}
        \end{sloppypar}
    \item \textbf{Accessors:} Methods \texttt{GetNumberOfRows()} and \texttt{GetNumberOfColumns()} provide access to matrix dimensions.
    \item \textbf{Operator Overloading:}
        \begin{itemize}
            \item The assignment operator (\texttt{operator=}) is overloaded for deep copying.
            \item The round bracket operator (\texttt{()}) is overloaded for 1-based element access, with both \texttt{const} and non-\texttt{const} versions and bounds checking via \texttt{assert}.
            \item Unary (\texttt{+}, \texttt{-}) and binary (\texttt{+}, \texttt{-}, \texttt{*}) operators are overloaded for matrix arithmetic, including addition, subtraction, multiplication (matrix-matrix, scalar-matrix, and matrix-vector). Assertions ensure valid dimensions.
            \item The output stream operator (\texttt{operator<<}) is overloaded for easy printing.
        \end{itemize}
    \item \textbf{Matrix Operations:}
        \begin{itemize}
            \item \texttt{Matrix Transpose() const}: Returns the transpose of the matrix.
            \item \texttt{double Determinant() const}: Calculates the determinant recursively using cofactor expansion, with assertions for square, non-empty matrices.
            \item \texttt{Matrix Inverse() const}: Computes the inverse of a square, non-singular matrix using the adjugate method, with checks for squareness and non-zero determinant.
            \item \texttt{Matrix PseudoInverse() const}: Calculates the Moore-Penrose pseudo-inverse, handling both $m \ge n$ and $m < n$ cases, and checks for singularity in the relevant matrices.
            \item Static utility methods \texttt{SwapRows} and \texttt{SwapRowsMatrixOnly} are provided for row operations, useful in solvers.
        \end{itemize}
\end{itemize}

\section{LinearSystem Class}
\label{sec:linearsystem_class}

The \texttt{LinearSystem} class (\texttt{LinearSystem.h}, \texttt{LinearSystem.cpp}) is designed to solve equations of the form $Ax=b$ where $A$ is a square, non-singular matrix.

\begin{figure}[H]
\lstinputlisting[language=C++, linerange={7-32}, caption={Implementation of the \texttt{LinearSystem} class}, captionpos=b]{../include/LinearSystem.h}
\end{figure}

\subsection{Features and Implementation}
\begin{sloppypar}
\begin{itemize}
    \item \textbf{Protected Data Members:} Includes \texttt{mSize} (size of the system), \texttt{mpA} (pointer to a \texttt{Matrix}), \texttt{mpb} (pointer to a \texttt{Vector}), and \texttt{mOwnsPointers} (ownership flag).
    \item \textbf{Constructors and Destructor:}
        \begin{itemize}
            \item The main constructor \texttt{LinearSystem(Matrix\& A, Vector\& b, bool copyData = true)} initializes the system, checks that $A$ is square and matches $b$, and manages data ownership.
            \item A copy constructor is provided for deep copying when needed.
            \item A default constructor initializes an empty system, though the project suggested restricting its use.
            \item The destructor frees memory if the object owns its data.
        \end{itemize}
    \item \textbf{Solver Method:}
        \begin{itemize}
            \item The public \texttt{virtual Vector Solve()} method uses Gaussian elimination with partial pivoting for stability, working on copies of $A$ and $b$.
            \item Returns the solution vector, and issues warnings or returns a zero vector if the matrix is nearly singular.
        \end{itemize}
    \item \textbf{Accessors:} Methods \texttt{GetMatrix()} and \texttt{GetRHSVector()} return copies of $A$ and $b$.
\end{itemize}
\end{sloppypar}

\section{PosSymLinSystem Class}
\label{sec:possymlinSystem_class}

The \texttt{PosSymLinSystem} class (\texttt{PosSymLinSystem.h}, \texttt{PosSymLinSystem.cpp}) extends \texttt{LinearSystem} to handle symmetric positive definite systems.

\begin{figure}[H]
\lstinputlisting[language=C++, linerange={6-15}, caption={Implementation of the \texttt{PosSymLinSystem} class}, captionpos=b]{../include/PosSymLinSystem.h}
\end{figure}

\subsection{Features and Implementation}
\begin{sloppypar}
\begin{itemize}
    \item \textbf{Inheritance:} Inherits publicly from \texttt{LinearSystem}, with protected access to base members.
    \item \textbf{Constructor:} The constructor checks that $A$ is symmetric using a private helper function. Positive definiteness is not explicitly checked.
    \item \textbf{Overridden Solve Method:} The \texttt{Solve()} method implements the Conjugate Gradient (CG) algorithm:
        \begin{itemize}
            \item Initializes $x_0$ as the zero vector, computes $r_0 = b - Ax_0$, and sets $p_0 = r_0$.
            \item Iterates until the residual norm is below a set tolerance or a maximum number of iterations is reached.
            \item Warns if the denominator for $\alpha$ is close to zero and notifies if convergence fails.
        \end{itemize}
\end{itemize}
\end{sloppypar}

\section{Solving Non-Square Systems}
\label{sec:nonsquare_systems}
The project also required handling linear systems where $A$ is not square.
\begin{itemize}
    \item The \texttt{Matrix::PseudoInverse()} method is the main tool for this, providing the Moore-Penrose pseudo-inverse for least-squares (over-determined) or minimum-norm (under-determined) solutions.
    \item For linear regression in Part B, the over-determined system $X\beta = y$ is solved by forming the normal equations $X^T X \beta = X^T y$, making the system square and solvable with \texttt{LinearSystem::Solve()}. This is equivalent to using the pseudo-inverse: $\beta = (X^T X)^{-1} X^T y$.
    \item Although Tikhonov regularization was mentioned in the requirements, it was not implemented as a separate solver. The focus was on the pseudo-inverse and normal equations for the projectâ€™s needs.
\end{itemize}
These classes together provide a comprehensive framework for linear algebra operations, meeting the requirements of Part A.